<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Token Ops - Admin - HumanAds</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=IBM+Plex+Mono:wght@400;500;600;700&family=Inter:wght@400;500;600;700;800&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="/styles.css">
  <link rel="icon" type="image/svg+xml" href="/favicon.svg">
  <style>
    .admin-page { padding: 24px 16px; max-width: 1200px; margin: 0 auto; }
    .admin-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 24px; flex-wrap: wrap; gap: 12px; }
    .admin-header h1 { font-family: var(--font-mono); font-size: 1.5rem; }

    /* Wallet Connection */
    .wallet-section { display: flex; align-items: center; gap: 8px; flex-wrap: wrap; position: relative; }
    .wallet-pill {
      display: flex; align-items: center; gap: 8px; padding: 8px 12px;
      background: var(--color-surface); border: 1px solid var(--color-border);
      border-radius: 24px; font-family: var(--font-mono); font-size: 0.75rem;
      cursor: pointer; transition: all 0.2s; -webkit-tap-highlight-color: transparent;
    }
    .wallet-pill:hover { border-color: var(--color-primary); }
    .wallet-pill:active { opacity: 0.7; }
    .wallet-pill.not-connected { background: rgba(255,59,48,0.1); border-color: rgba(255,59,48,0.3); color: #ff3b30; }
    .wallet-pill.connected { background: rgba(52,199,89,0.1); border-color: rgba(52,199,89,0.3); color: #34c759; }
    .wallet-pill.wrong-network { background: rgba(255,149,0,0.1); border-color: rgba(255,149,0,0.3); color: #ff9500; }
    .wallet-pill.verifying { background: rgba(0,122,255,0.1); border-color: rgba(0,122,255,0.3); color: #007aff; }
    .wallet-pill-main { display: flex; flex-direction: column; align-items: flex-start; }
    .wallet-pill-label { font-weight: 600; }
    .wallet-pill-sub { font-size: 0.65rem; opacity: 0.7; }
    .wallet-pill-arrow { opacity: 0.5; font-size: 0.6rem; }
    .wallet-badge { display: inline-block; padding: 2px 6px; border-radius: 4px; font-size: 0.65rem; }
    .wallet-badge.owner { background: rgba(255,107,53,0.2); color: #ff6b35; }
    .wallet-badge.not-owner { background: rgba(255,59,48,0.2); color: #ff3b30; }

    /* Action Sheet */
    .action-sheet-overlay { display: none; position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.5); z-index: 1000; }
    .action-sheet-overlay.show { display: block; }
    .action-sheet {
      position: fixed; bottom: 0; left: 0; right: 0;
      background: var(--color-surface); border-radius: 16px 16px 0 0;
      padding: 16px; padding-bottom: max(16px, env(safe-area-inset-bottom));
      z-index: 1001; transform: translateY(100%); transition: transform 0.3s ease-out;
    }
    .action-sheet-overlay.show .action-sheet { transform: translateY(0); }
    .action-sheet-header { text-align: center; padding-bottom: 12px; margin-bottom: 12px; border-bottom: 1px solid var(--color-border); }
    .action-sheet-title { font-family: var(--font-mono); font-size: 0.875rem; font-weight: 600; }
    .action-sheet-subtitle { font-size: 0.7rem; color: var(--color-text-muted); margin-top: 4px; }
    .action-sheet-btn {
      width: 100%; padding: 14px; margin-bottom: 8px; border-radius: 10px;
      font-family: var(--font-mono); font-size: 0.875rem; font-weight: 500;
      background: var(--color-bg); border: 1px solid var(--color-border);
      color: var(--color-text); cursor: pointer; text-align: center; -webkit-tap-highlight-color: transparent;
    }
    .action-sheet-btn:active { opacity: 0.7; }
    .action-sheet-btn.primary { background: var(--color-primary); border-color: var(--color-primary); color: white; }
    .action-sheet-btn.danger { color: #ff3b30; }
    .action-sheet-btn.cancel { margin-top: 8px; font-weight: 600; }

    /* Cards */
    .cards-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(280px, 1fr)); gap: 16px; margin-bottom: 24px; }
    .card { background: var(--color-surface); border: 1px solid var(--color-border); border-radius: 12px; padding: 20px; }
    .card-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 16px; }
    .card-title { font-family: var(--font-mono); font-size: 0.875rem; color: var(--color-text-muted); text-transform: uppercase; }
    .card-value { font-family: var(--font-mono); font-size: 1.75rem; font-weight: 600; }
    .card-sub { font-size: 0.75rem; color: var(--color-text-muted); margin-top: 4px; }
    .owner-card { background: linear-gradient(135deg, rgba(52,199,89,0.1) 0%, rgba(0,122,255,0.05) 100%); border-color: rgba(52,199,89,0.3); }
    .owner-form { display: flex; flex-direction: column; gap: 12px; }
    .form-group { display: flex; flex-direction: column; gap: 4px; }
    .form-label { font-size: 0.75rem; color: var(--color-text-muted); font-family: var(--font-mono); }
    .form-input { width: 100%; padding: 12px; font-family: var(--font-mono); font-size: 0.875rem; background: var(--color-bg); border: 1px solid var(--color-border); border-radius: 8px; color: var(--color-text); }
    .form-input:focus { outline: none; border-color: var(--color-primary); }
    .form-input:disabled { opacity: 0.5; cursor: not-allowed; }
    .form-select { width: 100%; padding: 12px; font-family: var(--font-mono); font-size: 0.875rem; background: var(--color-bg); border: 1px solid var(--color-border); border-radius: 8px; color: var(--color-text); cursor: pointer; }
    .form-hint { font-size: 0.7rem; color: var(--color-text-muted); }
    .form-hint.fixed { background: rgba(255,149,0,0.1); padding: 4px 8px; border-radius: 4px; }
    .faucet-card { background: linear-gradient(135deg, rgba(255,107,53,0.1) 0%, rgba(255,149,0,0.05) 100%); border-color: rgba(255,107,53,0.3); }
    .faucet-form { display: flex; flex-direction: column; gap: 12px; }
    .faucet-input { width: 100%; padding: 12px; font-family: var(--font-mono); font-size: 0.875rem; background: var(--color-bg); border: 1px solid var(--color-border); border-radius: 8px; color: var(--color-text); }
    .faucet-input:focus { outline: none; border-color: var(--color-primary); }
    .faucet-amount { display: flex; align-items: center; gap: 8px; }
    .faucet-amount-value { font-family: var(--font-mono); font-size: 1.25rem; font-weight: 600; color: var(--color-primary); }

    /* Buttons */
    .action-btn { padding: 12px 24px; background: var(--color-primary); color: white; border: none; border-radius: 8px; font-family: var(--font-mono); font-weight: 600; cursor: pointer; transition: opacity 0.2s; width: 100%; -webkit-tap-highlight-color: transparent; touch-action: manipulation; }
    .action-btn:hover { opacity: 0.9; }
    .action-btn:active { opacity: 0.7; }
    .action-btn:disabled { opacity: 0.5; cursor: not-allowed; }
    .action-btn.mint { background: #34c759; }
    .action-btn.transfer { background: #007aff; }

    /* Step Progress */
    .step-progress { margin-top: 12px; padding: 12px; background: rgba(0,0,0,0.2); border-radius: 8px; font-family: var(--font-mono); font-size: 0.75rem; }
    .step-item { display: flex; align-items: center; gap: 8px; padding: 4px 0; }
    .step-icon { width: 18px; text-align: center; }
    .step-icon.pending { color: var(--color-text-muted); }
    .step-icon.active { color: #007aff; }
    .step-icon.done { color: #34c759; }
    .step-icon.error { color: #ff3b30; }
    .step-text { flex: 1; }
    .step-text.active { color: #007aff; font-weight: 600; }
    .step-text.error { color: #ff3b30; }

    /* Status Messages */
    .status-msg { font-size: 0.75rem; padding: 8px; border-radius: 4px; margin-top: 8px; word-break: break-all; }
    .status-msg.success { background: rgba(52,199,89,0.2); color: #34c759; }
    .status-msg.error { background: rgba(255,59,48,0.2); color: #ff3b30; }
    .status-msg.info { background: rgba(0,122,255,0.2); color: #007aff; }
    .status-msg.warning { background: rgba(255,149,0,0.2); color: #ff9500; }

    /* Pending Alert Banner */
    .pending-alert {
      position: fixed; top: 0; left: 0; right: 0;
      background: #ff3b30; color: white; padding: 12px 16px;
      font-family: var(--font-mono); font-size: 0.8rem; text-align: center;
      z-index: 2000; display: none;
    }
    .pending-alert.show { display: block; }
    .pending-alert-btn {
      margin-left: 12px; padding: 4px 12px; background: white; color: #ff3b30;
      border: none; border-radius: 4px; font-weight: 600; cursor: pointer;
    }

    /* Config Info */
    .config-info { font-size: 0.75rem; color: var(--color-text-muted); margin-top: 12px; padding-top: 12px; border-top: 1px solid var(--color-border); }
    .config-row { display: flex; justify-content: space-between; margin-bottom: 4px; }
    .config-label { opacity: 0.7; }
    .config-value { font-family: var(--font-mono); }
    .config-value.status-ok { color: #34c759; }
    .config-value.status-error { color: #ff3b30; }
    .config-hint { font-size: 0.65rem; color: #ff9500; line-height: 1.4; }

    /* Table */
    .filters { display: flex; gap: 8px; flex-wrap: wrap; margin-bottom: 16px; }
    .filter-chip { padding: 6px 12px; border-radius: 20px; font-size: 0.75rem; font-family: var(--font-mono); background: var(--color-surface); border: 1px solid var(--color-border); cursor: pointer; -webkit-tap-highlight-color: transparent; }
    .filter-chip:hover, .filter-chip.active { border-color: var(--color-primary); color: var(--color-primary); }
    .data-table { width: 100%; border-collapse: collapse; }
    .data-table th, .data-table td { padding: 12px; text-align: left; border-bottom: 1px solid var(--color-border); font-size: 0.875rem; }
    .data-table th { font-family: var(--font-mono); font-size: 0.75rem; color: var(--color-text-muted); text-transform: uppercase; }
    .data-table tr:hover { background: rgba(255,255,255,0.02); }
    .status-badge { display: inline-block; padding: 2px 8px; border-radius: 4px; font-size: 0.7rem; font-family: var(--font-mono); font-weight: 600; }
    .status-badge.confirmed { background: rgba(52,199,89,0.2); color: #34c759; }
    .status-badge.submitted { background: rgba(0,122,255,0.2); color: #007aff; }
    .status-badge.pending { background: rgba(255,149,0,0.2); color: #ff9500; }
    .status-badge.failed { background: rgba(255,59,48,0.2); color: #ff3b30; }
    .type-badge { display: inline-block; padding: 2px 6px; border-radius: 3px; font-size: 0.65rem; font-family: var(--font-mono); }
    .type-badge.faucet { background: rgba(255,107,53,0.2); color: #ff6b35; }
    .type-badge.mint { background: rgba(52,199,89,0.2); color: #34c759; }
    .type-badge.transfer { background: rgba(0,122,255,0.2); color: #007aff; }
    .type-badge.owner_mint { background: rgba(52,199,89,0.2); color: #34c759; }
    .type-badge.owner_transfer { background: rgba(0,122,255,0.2); color: #007aff; }
    .loading, .empty { text-align: center; padding: 40px; color: var(--color-text-muted); }
    .id-cell { font-family: var(--font-mono); font-size: 0.75rem; color: var(--color-text-muted); }
    .address-cell { font-family: var(--font-mono); font-size: 0.7rem; max-width: 120px; overflow: hidden; text-overflow: ellipsis; }
    .table-container { overflow-x: auto; }
    .section-title { font-family: var(--font-mono); font-size: 1rem; margin: 24px 0 16px; }
    .tx-link { color: var(--color-primary); text-decoration: none; font-family: var(--font-mono); font-size: 0.7rem; }
    .tx-link:hover { text-decoration: underline; }

    /* Contract Source */
    .contract-card { background: linear-gradient(135deg, rgba(0,122,255,0.05) 0%, rgba(88,86,214,0.05) 100%); border-color: rgba(0,122,255,0.2); }
    .code-block { position: relative; background: var(--color-bg); border: 1px solid var(--color-border); border-radius: 8px; padding: 16px; max-height: 400px; overflow-y: auto; }
    .code-block pre { margin: 0; font-family: var(--font-mono); font-size: 0.7rem; line-height: 1.5; color: var(--color-text-muted); white-space: pre; overflow-x: auto; }
    .copy-btn { position: absolute; top: 8px; right: 8px; padding: 6px 12px; background: var(--color-primary); color: white; border: none; border-radius: 6px; font-family: var(--font-mono); font-size: 0.7rem; font-weight: 600; cursor: pointer; z-index: 1; }
    .copy-btn:hover { opacity: 0.9; }
    .copy-btn:active { opacity: 0.7; }
    .copy-btn.copied { background: #34c759; }
    .deploy-steps { list-style: none; padding: 0; margin: 12px 0 0; }
    .deploy-steps li { padding: 8px 0; font-size: 0.8rem; border-bottom: 1px solid var(--color-border); display: flex; gap: 8px; }
    .deploy-steps li:last-child { border-bottom: none; }
    .step-num { background: var(--color-primary); color: white; width: 20px; height: 20px; border-radius: 50%; display: flex; align-items: center; justify-content: center; font-size: 0.65rem; font-weight: 700; flex-shrink: 0; }
    .param-table { width: 100%; font-size: 0.75rem; margin-top: 8px; }
    .param-table td { padding: 4px 8px; font-family: var(--font-mono); border-bottom: 1px solid var(--color-border); }
    .param-table td:first-child { color: var(--color-text-muted); width: 120px; }
    .param-table .param-val { font-size: 0.65rem; word-break: break-all; cursor: pointer; }
    .param-table .param-val:hover { color: var(--color-primary); }
  </style>
</head>
<body>
  <!-- Pending Alert Banner -->
  <div class="pending-alert" id="pending-alert">
    MetaMaskに保留中の確認があります。
    <button class="pending-alert-btn" onclick="window.location.href='metamask://'>MetaMaskを開く</button>
  </div>

  <div class="app">
    <header class="header">
      <a href="/" class="logo">
        <svg class="logo-icon" viewBox="0 0 40 40" fill="none"><circle cx="20" cy="20" r="18" stroke="#FF6B35" stroke-width="3"/><circle cx="14" cy="20" r="4" fill="#FF6B35"/><path d="M22 16L32 20L22 24" stroke="#FF6B35" stroke-width="3" stroke-linecap="round" stroke-linejoin="round"/></svg>
        <span class="logo-text">HumanAds</span>
      </a>
      <div class="header-right">
        <button class="hamburger-btn" id="hamburger-btn" aria-label="Menu"><span class="hamburger-line"></span><span class="hamburger-line"></span><span class="hamburger-line"></span></button>
      </div>
    </header>
    <nav class="hamburger-menu" id="hamburger-menu" data-auto-init="false"></nav>
    <div class="menu-overlay" id="menu-overlay"></div>
    <main class="admin-page" id="content"><div class="loading">Loading token ops...</div></main>
  </div>

  <!-- Wallet Action Sheet -->
  <div class="action-sheet-overlay" id="wallet-action-sheet">
    <div class="action-sheet">
      <div class="action-sheet-header">
        <div class="action-sheet-title" id="action-sheet-title">Wallet</div>
        <div class="action-sheet-subtitle" id="action-sheet-subtitle"></div>
      </div>
      <button class="action-sheet-btn primary" id="action-reconnect">Reconnect Wallet</button>
      <button class="action-sheet-btn" id="action-copy">Copy Address</button>
      <button class="action-sheet-btn danger" id="action-disconnect">Disconnect</button>
      <button class="action-sheet-btn cancel" id="action-cancel">Cancel</button>
    </div>
  </div>

  <script src="/js/side-menu.js"></script>
  <script src="/js/humanads.js"></script>
  <script>
    // ============================================
    // Configuration
    // ============================================
    const CONFIG = {
      chainId: 11155111,
      chainIdHex: '0xaa36a7',
      chainName: 'Sepolia',
      husdContract: '0x62C2225D5691515BD4ee36539D127d0dB7dCeb67',
      ownerAddress: '0x64D6407757218ECbFc173C1efE0Fe7EdAaF67cC3',
      treasuryAddress: '0x0B9F043D4BcD45B95B72d4D595dEA8a31acdc017',
      decimals: 6,
      maxMintAmount: 1000000000,
      defaultMintAmount: 1000000,
      explorerUrl: 'https://sepolia.etherscan.io',
      defaultGasLimit: '0x30000', // 196608 - plenty for ERC20 mint
    };

    // ERC20 function selectors
    const SELECTORS = {
      mint: '0x40c10f19',      // mint(address,uint256)
      transfer: '0xa9059cbb',  // transfer(address,uint256)
      balanceOf: '0x70a08231', // balanceOf(address)
      totalSupply: '0x18160ddd', // totalSupply()
      owner: '0x8da5cb5b',     // owner() - Ownable
    };

    // ============================================
    // State
    // ============================================
    let walletAddress = null;
    let signerVerified = false;
    let isOwner = false;
    let currentChainId = null;
    let currentFilter = null;
    let serverConfig = null;
    let connectionState = 'disconnected';
    let mintInProgress = false;
    let transferInProgress = false;

    // ============================================
    // Logging
    // ============================================
    function log(level, message, data = null) {
      const ts = new Date().toISOString().substr(11, 12);
      console[level === 'error' ? 'error' : 'log'](`[${ts}] ${message}`, data || '');
    }

    // ============================================
    // Step Progress UI
    // ============================================
    const MINT_STEPS = [
      { id: 'refresh', label: '1. Refresh accounts' },
      { id: 'chain', label: '2. Check chain' },
      { id: 'owner', label: '3. Verify owner on-chain' },
      { id: 'send', label: '4. Send to MetaMask' },
      { id: 'confirm', label: '5. Waiting for confirmation' },
    ];

    function renderStepProgress(containerId, steps, currentStep, errorStep = null, errorMsg = null) {
      const container = document.getElementById(containerId);
      if (!container) return;

      const currentIdx = steps.findIndex(s => s.id === currentStep);
      const errorIdx = errorStep ? steps.findIndex(s => s.id === errorStep) : -1;

      container.innerHTML = `
        <div class="step-progress">
          ${steps.map((step, idx) => {
            let iconClass = 'pending';
            let icon = '○';
            let textClass = '';

            if (errorIdx >= 0 && idx === errorIdx) {
              iconClass = 'error';
              icon = '✗';
              textClass = 'error';
            } else if (idx < currentIdx || (currentStep === 'done' && idx < steps.length)) {
              iconClass = 'done';
              icon = '✓';
            } else if (idx === currentIdx && currentStep !== 'done') {
              iconClass = 'active';
              icon = '◉';
              textClass = 'active';
            }

            return `
              <div class="step-item">
                <span class="step-icon ${iconClass}">${icon}</span>
                <span class="step-text ${textClass}">${step.label}</span>
              </div>
            `;
          }).join('')}
          ${errorMsg ? `<div class="status-msg error" style="margin-top:8px">${errorMsg}</div>` : ''}
        </div>
      `;
    }

    function clearStepProgress(containerId) {
      const container = document.getElementById(containerId);
      if (container) container.innerHTML = '';
    }

    // ============================================
    // Provider Management
    // ============================================
    function getProvider() {
      if (typeof window.ethereum === 'undefined') {
        log('error', 'No ethereum provider');
        return null;
      }
      return window.ethereum;
    }

    async function getFreshAccounts() {
      const provider = getProvider();
      if (!provider) throw new Error('No wallet provider');

      log('info', 'eth_requestAccounts...');
      const accounts = await provider.request({ method: 'eth_requestAccounts' });
      log('info', 'Accounts:', accounts);

      if (!accounts || accounts.length === 0) {
        throw new Error('No accounts returned');
      }
      return accounts[0].toLowerCase();
    }

    async function getFreshChainId() {
      const provider = getProvider();
      if (!provider) throw new Error('No wallet provider');

      const chainIdHex = await provider.request({ method: 'eth_chainId' });
      return parseInt(chainIdHex, 16);
    }

    async function getOnchainOwner() {
      const provider = getProvider();
      if (!provider) throw new Error('No wallet provider');

      log('info', 'Reading owner() from contract...');
      const result = await provider.request({
        method: 'eth_call',
        params: [{ to: CONFIG.husdContract, data: SELECTORS.owner }, 'latest'],
      });
      // Result is 32 bytes padded address
      const ownerAddr = '0x' + result.slice(26).toLowerCase();
      log('info', 'On-chain owner:', ownerAddr);
      return ownerAddr;
    }

    // ============================================
    // Wallet Connection
    // ============================================
    async function connectWallet() {
      log('info', 'connectWallet');
      connectionState = 'verifying';
      updateWalletUI();

      const provider = getProvider();
      if (!provider) {
        alert('No wallet detected. Please open in MetaMask browser.');
        connectionState = 'disconnected';
        updateWalletUI();
        return false;
      }

      try {
        walletAddress = await getFreshAccounts();
        currentChainId = await getFreshChainId();
        isOwner = walletAddress === CONFIG.ownerAddress.toLowerCase();
        signerVerified = true;

        provider.on('accountsChanged', handleAccountsChanged);
        provider.on('chainChanged', handleChainChanged);

        connectionState = currentChainId === CONFIG.chainId ? 'connected' : 'wrong-network';
        updateWalletUI();
        refreshOnchainData();
        return true;
      } catch (e) {
        log('error', 'Connect failed', e);
        if (e.code === 4001) alert('Connection rejected');
        else alert('Failed: ' + e.message);
        connectionState = 'disconnected';
        signerVerified = false;
        walletAddress = null;
        updateWalletUI();
        return false;
      }
    }

    async function reconnectWallet() {
      log('info', 'reconnectWallet');
      connectionState = 'verifying';
      updateWalletUI();

      const provider = getProvider();
      if (!provider) {
        alert('No wallet detected');
        connectionState = 'disconnected';
        updateWalletUI();
        return false;
      }

      try {
        // Clear cached state
        ['walletconnect', 'wagmi.wallet', 'wagmi.connected'].forEach(k => {
          try { localStorage.removeItem(k); sessionStorage.removeItem(k); } catch(e) {}
        });

        // Force permission request
        try {
          await provider.request({ method: 'wallet_requestPermissions', params: [{ eth_accounts: {} }] });
        } catch (e) {
          log('info', 'wallet_requestPermissions failed, trying eth_requestAccounts');
        }

        walletAddress = await getFreshAccounts();
        currentChainId = await getFreshChainId();
        isOwner = walletAddress === CONFIG.ownerAddress.toLowerCase();
        signerVerified = true;

        provider.removeListener('accountsChanged', handleAccountsChanged);
        provider.removeListener('chainChanged', handleChainChanged);
        provider.on('accountsChanged', handleAccountsChanged);
        provider.on('chainChanged', handleChainChanged);

        connectionState = currentChainId === CONFIG.chainId ? 'connected' : 'wrong-network';
        updateWalletUI();
        refreshOnchainData();
        return true;
      } catch (e) {
        log('error', 'Reconnect failed', e);
        alert('Reconnect failed: ' + e.message);
        connectionState = 'disconnected';
        signerVerified = false;
        walletAddress = null;
        updateWalletUI();
        return false;
      }
    }

    function disconnectWallet() {
      log('info', 'disconnectWallet');
      const provider = getProvider();
      if (provider) {
        provider.removeListener('accountsChanged', handleAccountsChanged);
        provider.removeListener('chainChanged', handleChainChanged);
      }
      walletAddress = null;
      signerVerified = false;
      isOwner = false;
      currentChainId = null;
      connectionState = 'disconnected';
      updateWalletUI();
    }

    function handleAccountsChanged(accounts) {
      log('info', 'accountsChanged', accounts);
      if (accounts.length === 0) {
        walletAddress = null;
        signerVerified = false;
        isOwner = false;
        connectionState = 'disconnected';
      } else {
        walletAddress = accounts[0].toLowerCase();
        isOwner = walletAddress === CONFIG.ownerAddress.toLowerCase();
        signerVerified = true;
        connectionState = currentChainId === CONFIG.chainId ? 'connected' : 'wrong-network';
      }
      updateWalletUI();
      refreshOnchainData();
    }

    function handleChainChanged(chainIdHex) {
      log('info', 'chainChanged', chainIdHex);
      currentChainId = parseInt(chainIdHex, 16);
      if (walletAddress && signerVerified) {
        connectionState = currentChainId === CONFIG.chainId ? 'connected' : 'wrong-network';
      }
      updateWalletUI();
      refreshOnchainData();
    }

    // ============================================
    // Wallet UI
    // ============================================
    function updateWalletUI() {
      const section = document.getElementById('wallet-section');
      if (!section) return;

      let pillClass, pillLabel, pillSub, showArrow = false;

      switch (connectionState) {
        case 'disconnected':
          pillClass = 'not-connected';
          pillLabel = 'Not Connected';
          pillSub = 'Tap to connect';
          break;
        case 'verifying':
          pillClass = 'verifying';
          pillLabel = 'Connecting...';
          pillSub = 'Please wait';
          break;
        case 'wrong-network':
          pillClass = 'wrong-network';
          pillLabel = walletAddress ? walletAddress.substring(0,6) + '...' + walletAddress.substring(38) : 'Wrong Network';
          pillSub = 'Switch to Sepolia';
          showArrow = true;
          break;
        case 'connected':
          pillClass = 'connected';
          pillLabel = walletAddress.substring(0,6) + '...' + walletAddress.substring(38);
          pillSub = 'MetaMask • Sepolia';
          showArrow = true;
          break;
      }

      const badge = (connectionState === 'connected' || connectionState === 'wrong-network') && walletAddress
        ? `<span class="wallet-badge ${isOwner ? 'owner' : 'not-owner'}">${isOwner ? 'OWNER' : 'NOT OWNER'}</span>`
        : '';

      section.innerHTML = `
        <div class="wallet-pill ${pillClass}" id="wallet-pill">
          <div class="wallet-pill-main">
            <span class="wallet-pill-label">${pillLabel}</span>
            <span class="wallet-pill-sub">${pillSub}</span>
          </div>
          ${showArrow ? '<span class="wallet-pill-arrow">▼</span>' : ''}
        </div>
        ${badge}
      `;

      document.getElementById('wallet-pill')?.addEventListener('click', handleWalletPillClick);
      updateButtonStates();
    }

    function handleWalletPillClick() {
      if (connectionState === 'disconnected') connectWallet();
      else if (connectionState === 'connected' || connectionState === 'wrong-network') showWalletActionSheet();
    }

    function showWalletActionSheet() {
      document.getElementById('action-sheet-title').textContent = walletAddress ? walletAddress.substring(0,8) + '...' + walletAddress.substring(36) : 'Wallet';
      document.getElementById('action-sheet-subtitle').textContent = connectionState === 'wrong-network' ? 'Wrong network' : (isOwner ? 'Owner • Sepolia' : 'Sepolia');
      document.getElementById('wallet-action-sheet').classList.add('show');
    }

    function hideWalletActionSheet() {
      document.getElementById('wallet-action-sheet').classList.remove('show');
    }

    function copyWalletAddress() {
      if (!walletAddress) return;
      navigator.clipboard.writeText(walletAddress).then(() => {
        const title = document.getElementById('action-sheet-title');
        title.textContent = 'Copied!';
        setTimeout(() => hideWalletActionSheet(), 800);
      });
    }

    function updateButtonStates() {
      const mintBtn = document.getElementById('mint-btn');
      const transferBtn = document.getElementById('transfer-btn');
      const canExecute = signerVerified && currentChainId === CONFIG.chainId && isOwner;

      if (mintBtn) {
        mintBtn.disabled = !canExecute || mintInProgress;
        if (mintInProgress) mintBtn.textContent = 'Processing...';
        else if (!signerVerified) mintBtn.textContent = 'Connect Wallet First';
        else if (currentChainId !== CONFIG.chainId) mintBtn.textContent = 'Switch to Sepolia';
        else if (!isOwner) mintBtn.textContent = `Owner only`;
        else mintBtn.textContent = 'Mint hUSD';
      }

      if (transferBtn) {
        transferBtn.disabled = !canExecute || transferInProgress;
        if (transferInProgress) transferBtn.textContent = 'Processing...';
        else if (!signerVerified) transferBtn.textContent = 'Connect Wallet First';
        else if (currentChainId !== CONFIG.chainId) transferBtn.textContent = 'Switch to Sepolia';
        else if (!isOwner) transferBtn.textContent = `Owner only`;
        else transferBtn.textContent = 'Transfer to Treasury';
      }

      // Auto-fill faucet address when wallet connects
      autoFillFaucetAddress();
    }

    // ============================================
    // Pending Alert
    // ============================================
    function showPendingAlert() {
      document.getElementById('pending-alert').classList.add('show');
    }

    function hidePendingAlert() {
      document.getElementById('pending-alert').classList.remove('show');
    }

    // ============================================
    // Direct Mint - ALL IN ONE CLICK HANDLER
    // ============================================
    async function directMint() {
      if (mintInProgress) return;

      const toSelect = document.getElementById('mint-to');
      const amountInput = document.getElementById('mint-amount');
      const to = toSelect?.value || CONFIG.ownerAddress;
      const amount = parseInt(amountInput?.value) || CONFIG.defaultMintAmount;

      log('info', '=== MINT_CLICK ===', { time: new Date().toISOString(), to, amount, walletAddress, currentChainId, isOwner });

      if (amount <= 0 || amount > CONFIG.maxMintAmount) {
        showMintStatus(`Invalid amount (1 - ${CONFIG.maxMintAmount.toLocaleString()})`, 'error');
        return;
      }

      mintInProgress = true;
      updateButtonStates();

      const provider = getProvider();
      if (!provider) {
        showMintStatus('No wallet provider. Open in MetaMask browser.', 'error');
        mintInProgress = false;
        updateButtonStates();
        return;
      }

      let currentStep = 'refresh';

      try {
        // STEP 1: Refresh accounts
        renderStepProgress('mint-progress', MINT_STEPS, 'refresh');
        const freshAddr = await getFreshAccounts();
        walletAddress = freshAddr;
        log('info', 'Fresh address:', freshAddr);

        // STEP 2: Check chain
        currentStep = 'chain';
        renderStepProgress('mint-progress', MINT_STEPS, 'chain');
        const freshChain = await getFreshChainId();
        currentChainId = freshChain;
        log('info', 'Fresh chainId:', freshChain);

        if (freshChain !== CONFIG.chainId) {
          throw new Error(`Wrong chain (${freshChain}). Need Sepolia (${CONFIG.chainId}).`);
        }

        // STEP 3: Verify owner on-chain
        currentStep = 'owner';
        renderStepProgress('mint-progress', MINT_STEPS, 'owner');
        const onchainOwner = await getOnchainOwner();

        if (onchainOwner !== freshAddr) {
          throw new Error(`Not owner. On-chain owner: ${onchainOwner}, your address: ${freshAddr}`);
        }
        isOwner = true;
        updateWalletUI();

        // STEP 4: Build & send transaction
        currentStep = 'send';
        renderStepProgress('mint-progress', MINT_STEPS, 'send');

        const paddedTo = to.toLowerCase().replace('0x', '').padStart(64, '0');
        const amountWei = BigInt(amount) * BigInt(10 ** CONFIG.decimals);
        const paddedAmount = amountWei.toString(16).padStart(64, '0');
        const data = SELECTORS.mint + paddedTo + paddedAmount;

        const txParams = {
          from: freshAddr,
          to: CONFIG.husdContract,
          data: data,
          gas: CONFIG.defaultGasLimit, // Fixed gas - skip estimateGas
        };

        log('info', 'eth_sendTransaction params:', txParams);

        // STEP 5: Send & wait for MetaMask
        currentStep = 'confirm';
        renderStepProgress('mint-progress', MINT_STEPS, 'confirm');

        const txHash = await provider.request({
          method: 'eth_sendTransaction',
          params: [txParams],
        });

        log('info', 'TX broadcasted:', txHash);

        // SUCCESS
        renderStepProgress('mint-progress', MINT_STEPS, 'done');
        showMintStatus(
          `✅ Mint submitted! <a href="${CONFIG.explorerUrl}/tx/${txHash}" target="_blank" class="tx-link">${txHash.substring(0,20)}...</a>`,
          'success'
        );

        logTokenOp('owner_mint', txHash, freshAddr, to, amount);

        setTimeout(() => {
          refreshOnchainData();
          loadTokenOps(currentFilter);
        }, 5000);

      } catch (e) {
        log('error', 'Mint failed at step ' + currentStep, { code: e.code, message: e.message, data: e.data });

        let errorMsg = e.message;

        // Handle specific error codes
        if (e.code === -32002) {
          // Pending request in MetaMask
          errorMsg = 'MetaMaskに保留中の確認があります。MetaMaskアプリを開いて処理してください。';
          showPendingAlert();
        } else if (e.code === 4001) {
          errorMsg = 'Transaction rejected by user';
        } else if (e.code === -32603) {
          errorMsg = 'Internal error: ' + (e.data?.message || e.message);
        } else if (e.message?.includes('execution reverted')) {
          errorMsg = 'Transaction would revert: ' + e.message;
        }

        renderStepProgress('mint-progress', MINT_STEPS, currentStep, currentStep, errorMsg);

      } finally {
        mintInProgress = false;
        updateButtonStates();
      }
    }

    // ============================================
    // Direct Transfer
    // ============================================
    async function directTransfer() {
      if (transferInProgress) return;

      const amountInput = document.getElementById('transfer-amount');
      const amount = parseInt(amountInput?.value) || CONFIG.defaultMintAmount;

      log('info', '=== TRANSFER_CLICK ===', { time: new Date().toISOString(), amount, walletAddress, currentChainId, isOwner });

      if (amount <= 0 || amount > CONFIG.maxMintAmount) {
        showTransferStatus(`Invalid amount (1 - ${CONFIG.maxMintAmount.toLocaleString()})`, 'error');
        return;
      }

      transferInProgress = true;
      updateButtonStates();

      const provider = getProvider();
      if (!provider) {
        showTransferStatus('No wallet provider', 'error');
        transferInProgress = false;
        updateButtonStates();
        return;
      }

      let currentStep = 'refresh';

      try {
        // STEP 1: Refresh
        renderStepProgress('transfer-progress', MINT_STEPS, 'refresh');
        const freshAddr = await getFreshAccounts();
        walletAddress = freshAddr;

        // STEP 2: Chain
        currentStep = 'chain';
        renderStepProgress('transfer-progress', MINT_STEPS, 'chain');
        const freshChain = await getFreshChainId();
        currentChainId = freshChain;

        if (freshChain !== CONFIG.chainId) {
          throw new Error(`Wrong chain (${freshChain}). Need Sepolia.`);
        }

        // STEP 3: Verify owner (for transfer, user just needs balance, but we check anyway)
        currentStep = 'owner';
        renderStepProgress('transfer-progress', MINT_STEPS, 'owner');
        // For transfer we just check they have the tokens - skip owner check

        // STEP 4: Send
        currentStep = 'send';
        renderStepProgress('transfer-progress', MINT_STEPS, 'send');

        const paddedTo = CONFIG.treasuryAddress.toLowerCase().replace('0x', '').padStart(64, '0');
        const amountWei = BigInt(amount) * BigInt(10 ** CONFIG.decimals);
        const paddedAmount = amountWei.toString(16).padStart(64, '0');
        const data = SELECTORS.transfer + paddedTo + paddedAmount;

        const txParams = {
          from: freshAddr,
          to: CONFIG.husdContract,
          data: data,
          gas: CONFIG.defaultGasLimit,
        };

        log('info', 'eth_sendTransaction params:', txParams);

        // STEP 5: Confirm
        currentStep = 'confirm';
        renderStepProgress('transfer-progress', MINT_STEPS, 'confirm');

        const txHash = await provider.request({
          method: 'eth_sendTransaction',
          params: [txParams],
        });

        log('info', 'TX broadcasted:', txHash);

        renderStepProgress('transfer-progress', MINT_STEPS, 'done');
        showTransferStatus(
          `✅ Transfer submitted! <a href="${CONFIG.explorerUrl}/tx/${txHash}" target="_blank" class="tx-link">${txHash.substring(0,20)}...</a>`,
          'success'
        );

        logTokenOp('owner_transfer', txHash, freshAddr, CONFIG.treasuryAddress, amount);

        setTimeout(() => {
          refreshOnchainData();
          loadTokenOps(currentFilter);
        }, 5000);

      } catch (e) {
        log('error', 'Transfer failed at step ' + currentStep, { code: e.code, message: e.message });

        let errorMsg = e.message;
        if (e.code === -32002) {
          errorMsg = 'MetaMaskに保留中の確認があります。';
          showPendingAlert();
        } else if (e.code === 4001) {
          errorMsg = 'Rejected by user';
        }

        renderStepProgress('transfer-progress', MINT_STEPS, currentStep, currentStep, errorMsg);

      } finally {
        transferInProgress = false;
        updateButtonStates();
      }
    }

    function showMintStatus(msg, type) {
      const el = document.getElementById('mint-status');
      if (el) { el.className = 'status-msg ' + type; el.innerHTML = msg; }
    }

    function showTransferStatus(msg, type) {
      const el = document.getElementById('transfer-status');
      if (el) { el.className = 'status-msg ' + type; el.innerHTML = msg; }
    }

    // ============================================
    // On-chain Reads
    // ============================================
    async function readContract(selector, params = '') {
      const provider = getProvider();
      if (!provider) return null;
      const result = await provider.request({
        method: 'eth_call',
        params: [{ to: CONFIG.husdContract, data: selector + params }, 'latest'],
      });
      return result;
    }

    async function getTotalSupply() {
      try {
        const result = await readContract(SELECTORS.totalSupply);
        if (!result) return null;
        return Number(BigInt(result) / BigInt(10 ** CONFIG.decimals));
      } catch { return null; }
    }

    async function getBalance(address) {
      try {
        const padded = address.toLowerCase().replace('0x', '').padStart(64, '0');
        const result = await readContract(SELECTORS.balanceOf, padded);
        if (!result) return null;
        return Number(BigInt(result) / BigInt(10 ** CONFIG.decimals));
      } catch { return null; }
    }

    async function refreshOnchainData() {
      if (!signerVerified) return;
      try {
        const [supply, ownerBal, treasuryBal] = await Promise.all([
          getTotalSupply(),
          getBalance(CONFIG.ownerAddress),
          getBalance(CONFIG.treasuryAddress),
        ]);
        const supplyEl = document.getElementById('total-supply');
        const ownerEl = document.getElementById('owner-balance');
        const treasuryEl = document.getElementById('treasury-balance-live');
        if (supplyEl && supply !== null) supplyEl.textContent = supply.toLocaleString() + ' hUSD';
        if (ownerEl && ownerBal !== null) ownerEl.textContent = ownerBal.toLocaleString() + ' hUSD';
        if (treasuryEl && treasuryBal !== null) treasuryEl.textContent = treasuryBal.toLocaleString() + ' hUSD';
      } catch (e) { log('error', 'refreshOnchainData', e); }
    }

    // ============================================
    // Backend Logging
    // ============================================
    async function logTokenOp(type, txHash, from, to, amount) {
      try {
        await HumanAds.fetchApi('/api/admin/token-ops/log', {
          method: 'POST',
          body: JSON.stringify({ type, tx_hash: txHash, from_address: from, to_address: to, amount_cents: amount * 100, chain_id: CONFIG.chainId }),
        });
      } catch (e) { log('error', 'logTokenOp failed', e); }
    }

    // ============================================
    // Server Data Loading
    // ============================================
    async function loadBalances() {
      try {
        const res = await HumanAds.fetchApi('/api/admin/token-ops/balances');
        if (res.success) return res.data;
      } catch (e) { log('error', 'loadBalances', e); }
      // Fallback: at least get treasury key status from lightweight endpoint
      try {
        const envRes = await HumanAds.fetchApi('/api/admin/env-check');
        if (envRes.success) {
          return { config: { has_treasury_key: envRes.data.hasTreasuryKey, payout_mode: envRes.data.mode } };
        }
      } catch (e) { log('error', 'loadBalances fallback', e); }
      return null;
    }

    async function loadTokenOps(filter = null) {
      currentFilter = filter;
      const content = document.getElementById('content');

      try {
        const [balances, opsRes] = await Promise.all([
          loadBalances(),
          HumanAds.fetchApi(filter ? `/api/admin/token-ops?op_type=${filter}` : '/api/admin/token-ops')
        ]);

        if (!opsRes.success) {
          content.innerHTML = `<div class="empty">Error: ${opsRes.error?.message || 'Failed'}</div>`;
          return;
        }

        const ops = opsRes.data.token_ops || [];
        serverConfig = balances?.config || {};

        content.innerHTML = `
          <div class="admin-header">
            <h1>Token Ops (hUSD)</h1>
            <div class="wallet-section" id="wallet-section"></div>
          </div>

          <h2 class="section-title">Owner Operations (MetaMask)</h2>
          <div class="cards-grid">
            <div class="card owner-card">
              <div class="card-header"><span class="card-title">Owner Mint</span></div>
              <div class="owner-form">
                <div class="form-group">
                  <label class="form-label">Mint To</label>
                  <select id="mint-to" class="form-select">
                    <option value="${CONFIG.ownerAddress}">Owner (${CONFIG.ownerAddress.substring(0,10)}...)</option>
                    <option value="${CONFIG.treasuryAddress}">Treasury (${CONFIG.treasuryAddress.substring(0,10)}...)</option>
                  </select>
                </div>
                <div class="form-group">
                  <label class="form-label">Amount (hUSD)</label>
                  <input type="number" id="mint-amount" class="form-input" value="${CONFIG.defaultMintAmount}" min="1" max="${CONFIG.maxMintAmount}" />
                  <span class="form-hint">Max: ${CONFIG.maxMintAmount.toLocaleString()}</span>
                </div>
                <button class="action-btn mint" id="mint-btn" disabled>Connect Wallet First</button>
                <div id="mint-progress"></div>
                <div id="mint-status"></div>
              </div>
              <div class="config-info">
                <div class="config-row"><span class="config-label">Total Supply:</span><span class="config-value" id="total-supply">-</span></div>
                <div class="config-row"><span class="config-label">Owner Balance:</span><span class="config-value" id="owner-balance">-</span></div>
              </div>
            </div>

            <div class="card owner-card">
              <div class="card-header"><span class="card-title">Owner → Treasury Transfer</span></div>
              <div class="owner-form">
                <div class="form-group">
                  <label class="form-label">To (Fixed)</label>
                  <input type="text" class="form-input" value="${CONFIG.treasuryAddress}" disabled />
                  <span class="form-hint fixed">Treasury address</span>
                </div>
                <div class="form-group">
                  <label class="form-label">Amount (hUSD)</label>
                  <input type="number" id="transfer-amount" class="form-input" value="${CONFIG.defaultMintAmount}" min="1" max="${CONFIG.maxMintAmount}" />
                </div>
                <button class="action-btn transfer" id="transfer-btn" disabled>Connect Wallet First</button>
                <div id="transfer-progress"></div>
                <div id="transfer-status"></div>
              </div>
              <div class="config-info">
                <div class="config-row"><span class="config-label">Treasury Balance:</span><span class="config-value" id="treasury-balance-live">-</span></div>
                <div class="config-row"><span class="config-label">Contract:</span><span class="config-value">${CONFIG.husdContract.substring(0,10)}...</span></div>
              </div>
            </div>
          </div>

          <h2 class="section-title">Treasury → Advertiser Faucet</h2>
          <div class="cards-grid">
            <div class="card faucet-card">
              <div class="card-header"><span class="card-title">Send hUSD from Treasury</span></div>
              <div class="faucet-form">
                <div class="form-group">
                  <label class="form-label">Advertiser Address</label>
                  <input type="text" id="faucet-address" class="faucet-input" placeholder="0x... or connect wallet to auto-fill" />
                  <span class="form-hint">Connect MetaMask to auto-fill address</span>
                </div>
                <div class="faucet-amount">
                  <span>Amount:</span>
                  <span class="faucet-amount-value">$${((serverConfig.faucet_amount_cents || 100000) / 100).toLocaleString()}</span>
                  <span style="color:var(--color-text-muted)">hUSD</span>
                </div>
                <button class="action-btn" id="faucet-btn" ${!serverConfig.has_treasury_key ? 'disabled' : ''}>
                  ${serverConfig.has_treasury_key ? 'Send hUSD' : 'Treasury Key Not Set'}
                </button>
                <div id="faucet-status"></div>
              </div>
              <div class="config-info">
                <div class="config-row"><span class="config-label">From:</span><span class="config-value">Treasury (${CONFIG.treasuryAddress.substring(0,10)}...)</span></div>
                <div class="config-row"><span class="config-label">Gas:</span><span class="config-value">Treasury pays</span></div>
                <div class="config-row">
                  <span class="config-label">Treasury Key:</span>
                  <span class="config-value ${serverConfig.has_treasury_key ? 'status-ok' : 'status-error'}">
                    ${serverConfig.has_treasury_key ? '✓ Configured' : '✗ Not set'}
                  </span>
                </div>
                <div class="config-row"><span class="config-label">Mode:</span><span class="config-value">${serverConfig.payout_mode || 'ledger'}</span></div>
              </div>
            </div>

            <div class="card">
              <div class="card-header"><span class="card-title">Treasury Balance (Server)</span></div>
              <div class="card-value">${balances?.treasury ? balances.treasury.husd_display : '-'}</div>
              <div class="card-sub">hUSD (${balances?.treasury?.eth || '0'} ETH for gas)</div>
              ${balances?.treasury?.address ? `<div class="config-info"><div class="config-row"><span class="config-label">Address:</span><span class="config-value">${balances.treasury.address.substring(0,14)}...</span></div></div>` : ''}
            </div>

            <div class="card">
              <div class="card-header"><span class="card-title">Admin Balance (Server)</span></div>
              <div class="card-value">${balances?.admin ? balances.admin.husd_display : '-'}</div>
              <div class="card-sub">hUSD (${balances?.admin?.eth || '0'} ETH for gas)</div>
            </div>
          </div>

          <h2 class="section-title">Contracts (Remix Deploy)</h2>
          <div class="cards-grid">
            <div class="card contract-card" style="grid-column: 1 / -1;">
              <div class="card-header">
                <span class="card-title">HusdFaucet.sol</span>
                <span style="font-size:0.7rem;color:var(--color-text-muted)">Solidity ^0.8.20</span>
              </div>
              <div class="code-block">
                <button class="copy-btn" id="copy-sol-btn" onclick="copySolidity()">Copy .sol</button>
                <pre id="sol-source"></pre>
              </div>
              <ol class="deploy-steps">
                <li><span class="step-num">1</span><span>Remix で上記コードを貼り付け、Compiler 0.8.20+ でコンパイル</span></li>
                <li><span class="step-num">2</span><span>Deploy (Injected Provider - MetaMask, Sepolia) with params:</span></li>
              </ol>
              <table class="param-table">
                <tr><td>_husd</td><td class="param-val" onclick="copyText(this)">${CONFIG.husdContract}</td></tr>
                <tr><td>_treasury</td><td class="param-val" onclick="copyText(this)">${CONFIG.treasuryAddress}</td></tr>
                <tr><td>_signer</td><td class="param-val" onclick="copyText(this)">${CONFIG.ownerAddress}</td></tr>
                <tr><td>_openClaimAmt</td><td class="param-val" onclick="copyText(this)">1000000000</td></tr>
                <tr><td>_cooldown</td><td class="param-val" onclick="copyText(this)">86400</td></tr>
              </table>
              <ol class="deploy-steps" start="3">
                <li><span class="step-num">3</span><span>Treasury wallet で hUSD コントラクトの <code>approve(faucetAddress, type(uint256).max)</code> を実行</span></li>
                <li><span class="step-num">4</span><span>Admin が EIP-712 署名チケットを発行 → 広告主が <code>claimWithSignature()</code> を呼ぶ (ガス代は広告主)</span></li>
              </ol>
            </div>
          </div>

          <h2 class="section-title">Recent Operations (${ops.length})</h2>
          <div class="filters">
            <span class="filter-chip ${!filter ? 'active' : ''}" data-filter="">All</span>
            <span class="filter-chip ${filter === 'faucet' ? 'active' : ''}" data-filter="faucet">Faucet</span>
            <span class="filter-chip ${filter === 'owner_mint' ? 'active' : ''}" data-filter="owner_mint">Owner Mint</span>
            <span class="filter-chip ${filter === 'owner_transfer' ? 'active' : ''}" data-filter="owner_transfer">Owner Transfer</span>
          </div>

          <div class="table-container">
            ${ops.length === 0 ? '<div class="empty">No operations</div>' : `
              <table class="data-table">
                <thead><tr><th>ID</th><th>Type</th><th>From</th><th>To</th><th>Amount</th><th>TX Hash</th><th>Status</th><th>Created</th></tr></thead>
                <tbody>
                  ${ops.map(op => `
                    <tr>
                      <td class="id-cell">${op.id.substring(0,8)}...</td>
                      <td><span class="type-badge ${op.op_type}">${op.op_type}</span></td>
                      <td class="address-cell">${op.from_address ? op.from_address.substring(0,10)+'...' : '-'}</td>
                      <td class="address-cell">${op.to_address ? op.to_address.substring(0,10)+'...' : '-'}</td>
                      <td>${HumanAds.formatCurrency(op.amount_cents)}</td>
                      <td>${op.tx_hash ? (op.tx_hash.startsWith('SIMULATED_') ? `<span class="id-cell">${op.tx_hash.substring(0,16)}...</span>` : `<a href="${CONFIG.explorerUrl}/tx/${op.tx_hash}" target="_blank" class="tx-link">${op.tx_hash.substring(0,10)}...</a>`) : '-'}</td>
                      <td><span class="status-badge ${op.status}">${op.status}</span></td>
                      <td>${HumanAds.formatDate(op.created_at)}</td>
                    </tr>
                  `).join('')}
                </tbody>
              </table>
            `}
          </div>
        `;

        attachEventListeners();
        updateWalletUI();
        if (signerVerified) refreshOnchainData();

      } catch (e) {
        content.innerHTML = `<div class="empty">Error: ${e.message}</div>`;
      }
    }

    function attachEventListeners() {
      // DIRECT mint/transfer - no modal, one click does everything via MetaMask
      document.getElementById('mint-btn')?.addEventListener('click', directMint);
      document.getElementById('transfer-btn')?.addEventListener('click', directTransfer);
      document.getElementById('faucet-btn')?.addEventListener('click', sendFaucet);
      document.querySelectorAll('.filter-chip').forEach(chip => {
        chip.addEventListener('click', () => loadTokenOps(chip.dataset.filter || null));
      });
      // Auto-fill faucet address from connected wallet
      autoFillFaucetAddress();
      // Load contract source
      loadSoliditySource();
    }

    // ============================================
    // Contract Source Copy
    // ============================================
    const HUSD_FAUCET_SOL = `// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

/**
 * @title HusdFaucet
 * @author HumanAds
 * @notice Faucet for distributing hUSD to approved advertisers.
 *
 * Two claim modes:
 *   - claimWithSignature(): EIP-712 signed ticket from admin (primary, recommended)
 *   - claimOpen(): Simple cooldown-based faucet (can be disabled via openClaimEnabled)
 *
 * Setup:
 *   1. Deploy this contract
 *   2. Treasury calls husd.approve(thisContract, type(uint256).max)
 *   3. Admin signs claim tickets off-chain → advertiser calls claimWithSignature()
 *
 * Security:
 *   - ReentrancyGuard on all claim paths
 *   - SafeERC20 for non-standard token compatibility
 *   - Pausable for emergency stop
 *   - 2-step ownership transfer
 *   - EIP-712 signature verification (Sybil-resistant, AA/Safe wallet compatible)
 *   - Per-address nonce for replay protection
 *   - Pre-transfer allowance/balance checks with descriptive errors
 */

// ============================================
// Minimal interfaces (Remix-friendly, no imports needed)
// ============================================

interface IERC20 {
    function transfer(address to, uint256 amount) external returns (bool);
    function transferFrom(address from, address to, uint256 amount) external returns (bool);
    function balanceOf(address account) external view returns (uint256);
    function allowance(address owner, address spender) external view returns (uint256);
}

library SafeERC20 {
    error SafeERC20TransferFromFailed(address token, address from, address to, uint256 amount);

    function safeTransferFrom(IERC20 token, address from, address to, uint256 amount) internal {
        (bool success, bytes memory data) = address(token).call(
            abi.encodeWithSelector(token.transferFrom.selector, from, to, amount)
        );
        if (!success || (data.length != 0 && !abi.decode(data, (bool)))) {
            revert SafeERC20TransferFromFailed(address(token), from, to, amount);
        }
    }
}

contract HusdFaucet {
    using SafeERC20 for IERC20;

    // ============================================
    // Constants
    // ============================================
    uint256 public constant MAX_CLAIM_AMOUNT = 10_000_000_000;  // 10,000 hUSD (6 decimals)
    uint256 public constant MIN_COOLDOWN = 60;                   // 1 minute minimum

    // EIP-712
    bytes32 public constant CLAIM_TYPEHASH =
        keccak256("Claim(address recipient,uint256 amount,uint256 deadline,uint256 nonce)");

    // ============================================
    // Immutables
    // ============================================
    IERC20 public immutable husd;
    bytes32 public immutable DOMAIN_SEPARATOR;

    // ============================================
    // State
    // ============================================
    address public treasury;
    address public owner;
    address public pendingOwner;
    address public signer;              // admin who signs claim tickets
    uint256 public openClaimAmount;     // amount for open claims (cooldown-based)
    uint256 public cooldown;            // seconds between open claims
    bool public paused;
    bool public openClaimEnabled;       // toggle for simple faucet mode
    uint256 public totalClaimed;
    uint256 private _reentrancyStatus;

    mapping(address => uint256) public nonces;       // EIP-712 replay protection
    mapping(address => uint256) public lastClaim;    // cooldown tracking (open claims)
    mapping(address => uint256) public claimCount;   // total claims per address
    mapping(address => uint256) public totalReceived; // total tokens received per address

    // ============================================
    // Events
    // ============================================
    event Claimed(address indexed claimer, uint256 amount, uint256 timestamp, bool withSignature);
    event OpenClaimAmountUpdated(uint256 oldAmount, uint256 newAmount);
    event CooldownUpdated(uint256 oldCooldown, uint256 newCooldown);
    event TreasuryUpdated(address oldTreasury, address newTreasury);
    event SignerUpdated(address oldSigner, address newSigner);
    event OpenClaimToggled(bool enabled);
    event OwnershipTransferStarted(address indexed previousOwner, address indexed newOwner);
    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);
    event Paused(address account);
    event Unpaused(address account);

    // ============================================
    // Errors
    // ============================================
    error NotOwner();
    error NotPendingOwner();
    error IsPaused();
    error OpenClaimDisabled();
    error CooldownActive(uint256 nextClaimAt);
    error ZeroAddress();
    error AmountTooLarge(uint256 amount, uint256 max);
    error AmountZero();
    error CooldownTooShort(uint256 cooldown, uint256 min);
    error SignatureExpired(uint256 deadline);
    error InvalidSignature();
    error AllowanceTooLow(uint256 available, uint256 required);
    error TreasuryBalanceLow(uint256 available, uint256 required);

    // ============================================
    // Modifiers
    // ============================================
    modifier onlyOwner() {
        if (msg.sender != owner) revert NotOwner();
        _;
    }

    modifier whenNotPaused() {
        if (paused) revert IsPaused();
        _;
    }

    modifier nonReentrant() {
        require(_reentrancyStatus != 2, "ReentrancyGuard: reentrant call");
        _reentrancyStatus = 2;
        _;
        _reentrancyStatus = 1;
    }

    // ============================================
    // Constructor
    // ============================================
    constructor(
        address _husd,
        address _treasury,
        address _signer,
        uint256 _openClaimAmt,
        uint256 _cooldown
    ) {
        if (_husd == address(0)) revert ZeroAddress();
        if (_treasury == address(0)) revert ZeroAddress();
        if (_signer == address(0)) revert ZeroAddress();
        if (_openClaimAmt == 0) revert AmountZero();
        if (_openClaimAmt > MAX_CLAIM_AMOUNT) revert AmountTooLarge(_openClaimAmt, MAX_CLAIM_AMOUNT);
        if (_cooldown < MIN_COOLDOWN) revert CooldownTooShort(_cooldown, MIN_COOLDOWN);

        husd = IERC20(_husd);
        treasury = _treasury;
        signer = _signer;
        openClaimAmount = _openClaimAmt;
        cooldown = _cooldown;
        owner = msg.sender;
        openClaimEnabled = false;  // disabled by default, use signature mode
        _reentrancyStatus = 1;

        DOMAIN_SEPARATOR = keccak256(abi.encode(
            keccak256("EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)"),
            keccak256("HusdFaucet"),
            keccak256("1"),
            block.chainid,
            address(this)
        ));
    }

    // ============================================
    // Core: EIP-712 Signed Claim (Primary)
    // ============================================

    function claimWithSignature(
        uint256 amount,
        uint256 deadline,
        bytes calldata signature
    ) external nonReentrant whenNotPaused {
        if (block.timestamp > deadline) revert SignatureExpired(deadline);
        if (amount == 0) revert AmountZero();
        if (amount > MAX_CLAIM_AMOUNT) revert AmountTooLarge(amount, MAX_CLAIM_AMOUNT);

        uint256 nonce = nonces[msg.sender];
        nonces[msg.sender] = nonce + 1;

        bytes32 structHash = keccak256(abi.encode(
            CLAIM_TYPEHASH,
            msg.sender,
            amount,
            deadline,
            nonce
        ));
        bytes32 digest = keccak256(abi.encodePacked("\\x19\\x01", DOMAIN_SEPARATOR, structHash));
        address recovered = _recover(digest, signature);
        if (recovered == address(0) || recovered != signer) revert InvalidSignature();

        _executeClaim(msg.sender, amount, true);
    }

    // ============================================
    // Core: Open Claim (Simple faucet, toggle-able)
    // ============================================

    function claimOpen() external nonReentrant whenNotPaused {
        if (!openClaimEnabled) revert OpenClaimDisabled();

        uint256 last = lastClaim[msg.sender];
        if (last != 0 && block.timestamp < last + cooldown) {
            revert CooldownActive(last + cooldown);
        }

        lastClaim[msg.sender] = block.timestamp;
        _executeClaim(msg.sender, openClaimAmount, false);
    }

    // ============================================
    // Internal
    // ============================================

    function _executeClaim(address recipient, uint256 amount, bool withSignature) internal {
        uint256 allowanceAvailable = husd.allowance(treasury, address(this));
        if (allowanceAvailable < amount) revert AllowanceTooLow(allowanceAvailable, amount);

        uint256 balanceAvailable = husd.balanceOf(treasury);
        if (balanceAvailable < amount) revert TreasuryBalanceLow(balanceAvailable, amount);

        claimCount[recipient] += 1;
        totalReceived[recipient] += amount;
        totalClaimed += amount;

        husd.safeTransferFrom(treasury, recipient, amount);

        emit Claimed(recipient, amount, block.timestamp, withSignature);
    }

    function _recover(bytes32 digest, bytes calldata signature) internal pure returns (address) {
        if (signature.length != 65) return address(0);

        bytes32 r;
        bytes32 s;
        uint8 v;
        assembly {
            r := calldataload(signature.offset)
            s := calldataload(add(signature.offset, 32))
            v := byte(0, calldataload(add(signature.offset, 64)))
        }

        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {
            return address(0);
        }
        if (v != 27 && v != 28) return address(0);

        return ecrecover(digest, v, r, s);
    }

    // ============================================
    // View
    // ============================================

    function canClaimOpen(address account) external view returns (bool allowed, uint256 nextClaimAt) {
        if (!openClaimEnabled) return (false, 0);
        uint256 last = lastClaim[account];
        if (last == 0) return (true, 0);
        uint256 next = last + cooldown;
        if (block.timestamp >= next) return (true, 0);
        return (false, next);
    }

    function getNonce(address account) external view returns (uint256) {
        return nonces[account];
    }

    function remainingAllowance() external view returns (uint256) {
        return husd.allowance(treasury, address(this));
    }

    function treasuryBalance() external view returns (uint256) {
        return husd.balanceOf(treasury);
    }

    // ============================================
    // Admin: Configuration
    // ============================================

    function setOpenClaimAmount(uint256 _amount) external onlyOwner {
        if (_amount == 0) revert AmountZero();
        if (_amount > MAX_CLAIM_AMOUNT) revert AmountTooLarge(_amount, MAX_CLAIM_AMOUNT);
        emit OpenClaimAmountUpdated(openClaimAmount, _amount);
        openClaimAmount = _amount;
    }

    function setCooldown(uint256 _cooldown) external onlyOwner {
        if (_cooldown < MIN_COOLDOWN) revert CooldownTooShort(_cooldown, MIN_COOLDOWN);
        emit CooldownUpdated(cooldown, _cooldown);
        cooldown = _cooldown;
    }

    function setTreasury(address _treasury) external onlyOwner {
        if (_treasury == address(0)) revert ZeroAddress();
        emit TreasuryUpdated(treasury, _treasury);
        treasury = _treasury;
        if (!paused) {
            paused = true;
            emit Paused(msg.sender);
        }
    }

    function setSigner(address _signer) external onlyOwner {
        if (_signer == address(0)) revert ZeroAddress();
        emit SignerUpdated(signer, _signer);
        signer = _signer;
    }

    function setOpenClaimEnabled(bool _enabled) external onlyOwner {
        openClaimEnabled = _enabled;
        emit OpenClaimToggled(_enabled);
    }

    // ============================================
    // Admin: Pause
    // ============================================

    function pause() external onlyOwner {
        paused = true;
        emit Paused(msg.sender);
    }

    function unpause() external onlyOwner {
        paused = false;
        emit Unpaused(msg.sender);
    }

    // ============================================
    // Admin: 2-Step Ownership Transfer
    // ============================================

    function transferOwnership(address _newOwner) external onlyOwner {
        if (_newOwner == address(0)) revert ZeroAddress();
        pendingOwner = _newOwner;
        emit OwnershipTransferStarted(owner, _newOwner);
    }

    function acceptOwnership() external {
        if (msg.sender != pendingOwner) revert NotPendingOwner();
        emit OwnershipTransferred(owner, msg.sender);
        owner = msg.sender;
        pendingOwner = address(0);
    }
}`;

    function loadSoliditySource() {
      const el = document.getElementById('sol-source');
      if (el) el.textContent = HUSD_FAUCET_SOL;
    }

    function copySolidity() {
      navigator.clipboard.writeText(HUSD_FAUCET_SOL).then(() => {
        const btn = document.getElementById('copy-sol-btn');
        btn.textContent = 'Copied!';
        btn.classList.add('copied');
        setTimeout(() => { btn.textContent = 'Copy .sol'; btn.classList.remove('copied'); }, 2000);
      });
    }

    function copyText(el) {
      navigator.clipboard.writeText(el.textContent).then(() => {
        const orig = el.textContent;
        el.textContent = 'Copied!';
        el.style.color = '#34c759';
        setTimeout(() => { el.textContent = orig; el.style.color = ''; }, 1000);
      });
    }

    function autoFillFaucetAddress() {
      const input = document.getElementById('faucet-address');
      if (input && walletAddress && !input.value) {
        input.value = walletAddress;
      }
    }

    async function sendFaucet() {
      const addressInput = document.getElementById('faucet-address');
      const btn = document.getElementById('faucet-btn');
      const statusDiv = document.getElementById('faucet-status');
      const address = addressInput.value.trim();

      // Address validation: 0x + 40 hex chars
      if (!address || !/^0x[a-fA-F0-9]{40}$/.test(address)) {
        statusDiv.className = 'status-msg error';
        statusDiv.textContent = 'Enter valid EVM address (0x + 40 hex characters)';
        return;
      }

      btn.disabled = true;
      btn.textContent = 'Treasury sending...';
      statusDiv.className = 'status-msg info';
      statusDiv.innerHTML = 'Treasuryからトランザクション送信中... 15-30秒かかります';

      // AbortController for 60s timeout (on-chain tx can be slow)
      const controller = new AbortController();
      const timeoutId = setTimeout(() => controller.abort(), 60000);

      try {
        const res = await HumanAds.fetchApi('/api/admin/faucet', {
          method: 'POST',
          body: JSON.stringify({ advertiser_address: address }),
          signal: controller.signal,
        });

        clearTimeout(timeoutId);

        if (res.success) {
          statusDiv.className = 'status-msg success';
          const amt = res.data.amount_cents ? `$${(res.data.amount_cents / 100).toLocaleString()}` : '';
          statusDiv.innerHTML = `Sent ${amt} hUSD from Treasury! <a href="${CONFIG.explorerUrl}/tx/${res.data.tx_hash}" target="_blank" class="tx-link">${res.data.tx_hash?.substring(0,20) || 'pending'}...</a>`;
          setTimeout(() => loadTokenOps(currentFilter), 3000);
        } else {
          statusDiv.className = 'status-msg error';
          const errMsg = res.error?.message || 'Failed';
          statusDiv.innerHTML = `${errMsg} <button class="action-btn" style="margin-top:8px;padding:8px 16px;font-size:0.75rem;" onclick="sendFaucet()">Retry</button>`;
        }
      } catch (e) {
        clearTimeout(timeoutId);
        statusDiv.className = 'status-msg error';
        const errMsg = e.name === 'AbortError'
          ? 'Request timed out (60s). The transaction may still be processing on-chain.'
          : e.message;
        statusDiv.innerHTML = `${errMsg} <button class="action-btn" style="margin-top:8px;padding:8px 16px;font-size:0.75rem;" onclick="sendFaucet()">Retry</button>`;
      } finally {
        btn.disabled = !serverConfig?.has_treasury_key;
        btn.textContent = serverConfig?.has_treasury_key ? 'Send hUSD' : 'Treasury Key Not Set';
      }
    }

    // ============================================
    // Action Sheet Listeners
    // ============================================
    function initActionSheetListeners() {
      document.getElementById('wallet-action-sheet').addEventListener('click', (e) => {
        if (e.target.id === 'wallet-action-sheet') hideWalletActionSheet();
      });
      document.getElementById('action-reconnect').addEventListener('click', () => { hideWalletActionSheet(); reconnectWallet(); });
      document.getElementById('action-copy').addEventListener('click', copyWalletAddress);
      document.getElementById('action-disconnect').addEventListener('click', () => { hideWalletActionSheet(); disconnectWallet(); });
      document.getElementById('action-cancel').addEventListener('click', hideWalletActionSheet);
    }

    // ============================================
    // Initialization
    // ============================================
    (async function() {
      log('info', 'Init Token Ops');

      const meRes = await HumanAds.fetchApi('/me');
      if (!meRes.success || !meRes.data?.user?.is_admin) {
        window.location.href = '/admin';
        return;
      }

      await loadTokenOps();
      SideMenu.init(true, true);
      initActionSheetListeners();

      // Auto-verify existing connection
      const provider = getProvider();
      if (provider) {
        try {
          const accounts = await provider.request({ method: 'eth_accounts' });
          if (accounts.length > 0) {
            walletAddress = accounts[0].toLowerCase();
            currentChainId = await getFreshChainId();
            isOwner = walletAddress === CONFIG.ownerAddress.toLowerCase();
            signerVerified = true;
            connectionState = currentChainId === CONFIG.chainId ? 'connected' : 'wrong-network';
            provider.on('accountsChanged', handleAccountsChanged);
            provider.on('chainChanged', handleChainChanged);
            updateWalletUI();
            refreshOnchainData();
          }
        } catch (e) { log('error', 'Auto-connect failed', e); }
      }

      log('info', 'Token Ops ready');
    })();
  </script>
  <script src="/js/env-banner.js"></script>
</body>
</html>
